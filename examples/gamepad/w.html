<!DOCTYPE html>
<html lang="en">
	<head>
		<title>XR.js | Pointer</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
        <link rel="stylesheet" href="/css/main.css" />
      </head>
	<body>
           
	<script type="module">
		import   '/js/three/build/three.js';
	import { VRButton } 				from '/node_modules/three/examples/jsm/webxr/VRButton.js';
	import { OrbitControls } 			from '/node_modules/three/examples/jsm/controls/OrbitControls.js';

	import { XRControllerModelFactory } from '/node_modules/three/examples/jsm/webxr/XRControllerModelFactory.js';
	

		var intersecting;
			var clock = new THREE.Clock();
            var room, camera, scene, raycaster, renderer;
			var controller, controller1;
			var tempMatrix = new THREE.Matrix4();
			var intersectedObject, intersectedPosition; // Contains the object and intersected position of where the user is pointing.
			var loader = new THREE.TextureLoader();

			var floor;
            var mainmenu = new THREE.Group(); // main menu
			var dolly; // The dolly contains the camera and the controller.  Move the dolly to move the camera and ontroller.
			init();
			renderer.setAnimationLoop( render );

			function init() {
				renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.xr.enabled = true;
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				document.body.appendChild(renderer.domElement);

				//container = document.createElement( 'div' );
				//document.body.appendChild( container );


				
                // main three.js scene
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x222222 );

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 1000 );
				
													 const controls = new OrbitControls( camera, renderer.domElement );

                // dolly allows us to reposition the user
				dolly = new THREE.Group();
                dolly.position.set( 0, 0, 3 );
				dolly.add( camera );
				scene.add( dolly );
                              
				room = new THREE.Group();
				scene.add( room );
				
                dolly.add(mainmenu);
				raycaster = new THREE.Raycaster();

				
													 camera.position.set( 0, 20, 100 );
			  controls.update();
                renderer.setClearColor( 0x000000, 0 ); // the default

				function onSelectStart(e) {
					// Add code for when user presses their controller
                    console.log(e)
					console.log('left trigger');
					console.log(intersecting);
				}
                                                     
				function onSelectEnd(e) {
					// Add code for when user releases the button on their controller
                    console.log(e)
				}

				// controllers
				controller = renderer.xr.getController(0);
				controller.addEventListener( 'selectstart', onSelectStart );
				controller.addEventListener( 'selectend', onSelectEnd );
				controller.addEventListener( 'connected', function ( event ) { this.add( buildController( event.data ) ); } );
				 
				controller1 = renderer.xr.getController(1);
				controller1.addEventListener( 'selectstart', onSelectStart );
				controller1.addEventListener( 'selectend', onSelectEnd );
				controller1.addEventListener( 'connected', function ( event ) { this.add( buildController( event.data ) ); } );
				controller1.addEventListener( 'squeezestart', function ( event ) { controller1; } );
                                                         
				//  controller1.addEventListener( 'connected', (e) => { controller1.gamepad = e.data.gamepad; });
				//  controller.addEventListener( 'disconnected', function () { this.remove( this.children[ 0 ] ); } );
				dolly.add( controller ).add( controller1 );


				var controllerGrip = renderer.xr.getControllerGrip( 0 );
				controllerGrip.add( new XRControllerModelFactory().createControllerModel( controllerGrip ) );
				var controllerGrip1 = renderer.xr.getControllerGrip( 1 );
				controllerGrip1.add( new XRControllerModelFactory().createControllerModel( controllerGrip1 ) );

				dolly.add( controllerGrip );
				dolly.add( controllerGrip1 );

				// create Enter VR button
				document.body.appendChild( VRButton.createButton( renderer ) );
				// document.body.appendChild( ARButton.createButton( renderer ) );

}


// Create laser pointer line
function buildController( data ) {

    switch ( data.targetRayMode ) {
        case 'tracked-pointer':
            var geometry = new THREE.BufferGeometry();
            geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 1 ], 3 ) );
            geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );

            var material = new THREE.LineBasicMaterial( {
                vertexColors: true,
                blending: THREE.AdditiveBlending
            } );

            return new THREE.Line( geometry, material );

        case 'gaze':
            var geometry = new THREE.RingBufferGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );
            var material = new THREE.MeshBasicMaterial( {
                opacity: 0.5,
                transparent: false
            });
            return new THREE.Mesh( geometry, material );
    }
}
          


var hovering = [];
function handleCollisions(){
	
// find what user is pointing at
tempMatrix.identity().extractRotation( controller.matrixWorld );
raycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld );
raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );

var intersects = raycaster.intersectObjects( mainmenu.children );
if ( intersects.length > 0 ) {
	
	intersectedObject = intersects[0].object;
	intersectedPosition = intersects[0].point;
	// intersectedObject.scale.x = 2;
	//console.log(intersectedObject.uuid)
	intersecting = intersectedObject.name;
	
	if(hovering.length > 1){

		//	hovering[0].scale.y = 1;
		hovering.forEach(element => element.scale.y = 1);

		hovering = []
	}
	if (hovering.indexOf(intersecting) === -1) {
		//console.log("element doesn't exist");
		//intersectedObject.scale.x = 1.1;
		intersectedObject.scale.y = 1.1;
		hovering.push(intersectedObject);
		//console.log(hovering);
		
	}
else {
//console.log("element found");
  //console.log(hovering)
}

	
	
} else {
	
		if(hovering.length > 0){
			hovering[0].scale.y = 1;
			
		}
	hovering = []
	intersectedObject = undefined;
}
}
function render() {
	handleCollisions();
	renderer.render( scene, camera );
}
// create "synth.ist" text
function createFont(parenta, text){
	// font
	const font = new THREE.FontLoader();
	font.load( '/assets/fonts/helvetiker_bold.typeface.json', function ( font ) {
		const textGeo = new THREE.TextBufferGeometry( text, {
			font: font,
			size: 0.05,
			height: 0.01,
			curveSegments: 12,
			bevelThickness: 0.001,
			bevelSize: 0.001,
			bevelEnabled: true

		} );

		textGeo.computeBoundingBox();
		const centerOffset = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );
		
		const textMaterial = new THREE.MeshPhongMaterial( {
			color: 0xff0000,
			specular: 0xffffff
		} );
		
		const mesh = new THREE.Mesh( textGeo, textMaterial );
		mesh.position.x = centerOffset;
		mesh.position.y = 0.1;
		
		mesh.castShadow = true;
		mesh.receiveShadow = true;

		parenta.add( mesh );
		//objects.push(mesh);

	} );
	}createFont(scene, 'hi')
// for each in array, create a menu item
var menuItems = ['sine', 'triangle', 'square', 'sawtooth'];

menuItems.forEach(function(e, i) {
    createMenu(e,i);
});

// create menu items
function createMenu(e, i) {
    var geometry = new THREE.BoxBufferGeometry(0.3, 0.3, 0.02);
    
    loader.load('/assets/textures/wave/' + e + '.jpg', function ( texture ) {

    // Stop texture being blurred
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;

    // Light aware material
    var material = new THREE.MeshLambertMaterial ({
		map: texture,
		combine: THREE.MixOperation,
        reflectivity: .5
    });
 
    // for ( var i = 0; i < 1; i ++ ) {
	var menuItemGroup = new THREE.Group(); // main menu

    var menuItem = new THREE.Mesh(geometry, material);
	//menuItem.castShadow = true;
	//menuItem.receiveShadow = true;
	menuItem.position.x = i *  0.31;
	menuItem.position.y = 0;
	menuItem.name = e;
		

		createFont(menuItem, e)
		mainmenu.add( menuItemGroup );

    mainmenu.add( menuItem );
    // }
    });

	mainmenu.position.x = -0.5;
	mainmenu.position.y = 1;
	mainmenu.position.z = -2;
	mainmenu.rotation.x = THREE.Math.degToRad(-10);
	//var worldAxis = new THREE.AxesHelper(1);
	//mainmenu.add(worldAxis);
}
           

// lights
var light = new THREE.DirectionalLight( 0xFFFFFF, 1, 100 );
light.position.set(  1, 10, -0.5 );
light.castShadow = true;
light.shadow.mapSize.width  = 2048;
light.shadow.mapSize.height = 2048;
light.shadow.camera.near    =    1;
light.shadow.camera.far     =   12;
scene.add( light );
scene.add( new THREE.HemisphereLight( 0x909090, 0x404040 ));


			// add floor
			var floor = new THREE.Mesh(
				new THREE.PlaneBufferGeometry( 6, 6, 12, 12 ),
				new THREE.MeshStandardMaterial({
					roughness: 1.0,
					metalness: 0.1,
					color: 0xff0000,
					transparent: true,
					opacity: 0.4
				})
			);
			floor.rotation.x = Math.PI / -2
			floor.receiveShadow = true
			scene.add( floor )

// add head
var head = new THREE.Mesh(
    new THREE.OctahedronGeometry( 0.1, 2 ),
	new THREE.MeshStandardMaterial()
);

head.castShadow = true;
camera.add( head );
// make head double sided
// head.traverse( function( node ) { if( node.material ) { node.material.side = THREE.DoubleSide; } });
													 
										
		</script>
	</body>
</html>
